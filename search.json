[{"title":"看雪2018团队赛-第四题-盗梦空间","url":"/2019/01/02/看雪2018团队赛-第四题-盗梦空间/","content":"# 简述\n\n题目下载：https://ctf.pediy.com/attach-download-133.htm\n\n知识点涉及：\n- 反调试技巧\n- OD清洗rtrace文件脚本\n- 变异tea算法\n\n下面按照正确的解题思路讲解，参照了风间仁大佬wp，链接见文末。\n\n# 题目概览\n\n拿到题目，先运行一下程序，效果如下：\n\n![](看雪2018团队赛-第四题-盗梦空间/img01.png)\n\nCrackMe类型，需要提供正确的序列号获取flag.\n\n接着用IDA查看一下程序主逻辑：\n\n![](看雪2018团队赛-第四题-盗梦空间/img02.png)\n\n可以看到程序主体只是一个if-else结构，重点取决于check函数：\n\n![](看雪2018团队赛-第四题-盗梦空间/img03.png)\n\ncheck函数前半部分首先是一堆局部变量的初始化，后面分析可知是预存的5个4x4的矩阵，这里先列出：\n\n```\nmat0 = [[0, 0, 0, 0],\n        [10, 15, 2, 13,], \n        [10, 8, 6, 15,], \n        [0, 5, 3, 0],]\nmat1 = [[16, 0, 16, 14,], \n        [3, 10, 6, 0,], \n        [0, 7, 13, 6,], \n        [4, 7, 0, 2],]\nmat2 = [[6, 16, 0, 12,], \n        [0, 11, 16, 12,], \n        [8, 12, 12, 0,], \n        [6, 0, 11, 13],]\nmat3 = [[16, 14, 13, 14,], \n        [4, 0, 0, 16,], \n        [5, 0, 0, 3,], \n        [5, 16, 14, 16],]\nexpected = [[222105, 494358, 443201, 423901,], \n            [310311, 700114, 629640, 620483,], \n            [301566, 676368, 606711, 605590,], \n            [149250, 339264, 304846, 301296],]\n```\n\n可以看到4个matX矩阵都至少包含4个0。\n\n接着就是进行上图操作，校验输入序列号(sn)格式，是否满足：char ∈ (0-9|A-F),len == 16. 如果格式正确就把16长度字符串转换成2个8长度的16进制数sn0,sn1. 举例：\n\n```\ninput: 1234567890ABCDEF\nsn0:0x12345678  sn1:0x90ABCDEF\n```\n\n接下来调用了confuseFunc函数，这个是一个混淆严重的函数，Hex Rays得到的伪C代码并不可信.需要借助别的工具分析，见下文。\n> 看到char ∈ (0-9|A-F),就应该想到str2hex.\n\ncheck函数后半部分：\n\n![](看雪2018团队赛-第四题-盗梦空间/img04.png)\n\n首先看到了IsDebuggerPresent()反调试，按照现在目前的逻辑我们应该进入else分支，在else分支中我们把上面提到的4个mat矩阵中包含的0分别用做了一定变换的sn0,sn1值填充，然后进行4个mat矩阵连乘，要求结果矩阵和expected矩阵相等，即可得到flag。\n\n看样子整体逻辑已经捋清楚了，接下来用z3做下尝试。\n\n# z3的尝试\n\n利用z3正向约束求解，最终是16个未知数，16个约束方程。最终结果是无解的。当时做对z3不熟，用matlab求解的，无解。在这里也不详细用z3求解了，丢个链接：[Z3 API IN PYTHON 中文文档 ](https://arabelatso.github.io/2018/06/14/Z3%20API%20in%20Python/)，方便以后查阅。\n\n另外，介绍一个技巧，之前用python以为不好获取含未知数的表达式运算，比如，该题目含未知数的矩阵乘法，如何得到矩阵乘法后的16个未知数方程，以为需要考虑字符串之类。所以采用了matlab求解。too native，这里参考Riatre大佬脚本发现：(z3未知量 + python乘法)可以直接得到未知数方程。\n\n```\ndef matmul(A, B):\n  res = [[0] * 4 for _ in range(4)]\n  for i in range(4):\n    for j in range(4):\n      for k in range(4):\n        res[i][j] += A[i][k] * B[k][j]\n  return res\n\nprint(matmul(mat0, mat1))\n\nOutput:\n[[0 + x0*16 + y0*3 + y1*x7 + x1*4, 0 + x0*x4 + y0*10 + y1*7 + x1*7, 0 + x0*16 + y0*6 + y1*13 + x1*x6, 0 + x0*14 + y0*x5 + y1*6 + x1*2], \n[205 + 2*x7 + 52, 0 + 10*x4 + 150 + 14 + 91, 276 + 13*x6, 140 + 15*x5 + 12 + 26], \n[184 + 6*x7 + 60, 0 + 10*x4 + 80 + 42 + 105, 286 + 15*x6, 140 + 8*x5 + 36 + 30], \n[0 + x3*16 + 15 + 3*x7 + x2*4, 0 + x3*x4 + 50 + 21 + x2*7, 0 + x3*16 + 30 + 39 + x2*x6, 0 + x3*14 + 5*x5 + 18 + x2*2]]\n```\n\n> 尽量用z3+python求解约束。\n\n# attach的试探\n\n既然按照程序正常的逻辑无法求解，那就要想到反调试了，可能看到的程序逻辑并不是真正的执行逻辑：\n\n程序可能检测到调试器后，对程序逻辑进行了自修改，从而执行了错误的逻辑。我们采用调试器执行程序，发现程序并没有进行自修改，IDA静态查看的程序逻辑，的确是我们动态执行的逻辑。\n\n尝试attach到程序，发现程序的执行逻辑的确发生了变化：\n\n![](看雪2018团队赛-第四题-盗梦空间/img05.png)\n\n可以看到，程序并未执行矩阵运算，执行的是原IsDebuggerPresent()的If分支里的逻辑。\n\n在汇编层面可以看到：\n![](看雪2018团队赛-第四题-盗梦空间/img06.png)\n\n.text:003A16BD处的指令被修改了，直接跳入了If分支执行。\n\n对照一下静态分析时的汇编：\n\n![](看雪2018团队赛-第四题-盗梦空间/img07.png)\n\n连续执行mov eax，imm两次，的确是可疑的点，大佬们直接就看出来了吧。\n\n> 优先使用attach方式比直接使用调试器debug更容易发现问题。\n\n# 反调试\n\n接下来，是反调试的定位。并不是很好定位，仔细总结一下该题目的反调试技巧：\n- 静态分析时看到的是错误的执行逻辑，检测到调试器时，不修改原逻辑。未检测到调试器时，自修改成正确的执行逻辑。\n\n普通的反调试是，检测到调试器时，修改执行逻辑，这样可以通过下内存写入断点来定位反调试位置。对于该题而言，检测到调试器，不修改。那么就只能通过检索字符串去定位到反调试函数了，目前没有考虑到比较好的方法。\n\n通过检索字符串可以定位到NtQueryInformationProcess字符串：\n\n![](看雪2018团队赛-第四题-盗梦空间/img08.png)\n\n通过调试发现，程序运行时会执行这一段被混淆的代码，调用NtQueryInformationProcess函数，并对.text:003A16BD处的指令进行修改，如下：\n\n![](看雪2018团队赛-第四题-盗梦空间/img09.png)\n\n定位到了反调试后，看一下真正的执行逻辑：\n\n![](看雪2018团队赛-第四题-盗梦空间/img10.png)\n\n最终比较的是sn0 == 0x87654321 & sn1 == 0x12345678\n\n运行发现调用confuseFunc函数后的序列号sn0,sn1值发生变化。说明真正check序列号的代码存在于confuseFunc中，接下来就是重点分析混淆严重的confuseFunc函数。\n\n# idc & run trace 上场\n\n回顾一下，程序的反调试只修改了一句指令，使得跳转执行到正确的分支上。真正的check序列号的算法存在于confuseFunc中。confuseFunc是没有修改的，可以直接用调试器debug动态调试confuseFunc。\n\nconfuseFunc函数内部包含反调试，无用循环，SMC等。每执行完一段代码块，都有反调试来控制是否跳转到正确分支。由于代码块混淆严重，且数量过多，我们需要采用OD的run trace功能来记录真正执行过的指令，然后对rtrace文件指令清洗得到最终的校验算法。\n\n在这之前，我们先分析一下confuseFunc函数开始处的代码块：\n\n![](看雪2018团队赛-第四题-盗梦空间/img11.png)\n\n通过调试发现，首先上图绿框选中处是反调试，查看是否设置BeingDebugged位并存入eax，红框选中处是一段循环，调试情况下得到的eax结果是错误的，当BeingDebugged值为0时，该段循环的eax结果一直为0，离开该循环后，才能跳转到正确的执行逻辑。可以看到该无用循环进行了0x0F204C次，会对后续的的run trace带来困扰（会记录巨量的无用指令，增大存储空间，影响跟踪速度）。这一无用循环应该是出题者刻意设置的，用来阻碍分析者跟踪指令。\n\n所以第一步，我们应该先利用idc脚本把这一块无用循环nop掉。然后再用OD跟踪指令。\n## idc\npattern如下：\n\n```\ncode:\n    jb xxxx\n    call $+5\npattern:\n    72 ?? E8 00 00 00 00\n\n```\n\n对confuseFunc函数startPos-endPos之间pattern全用90(nop)填充即可。\n\n## run trace\n\n接下来进行run trace:\n\n>注意，进行run trace时，使用吾爱OD的英文原版，其汉化版Command列，没有列名，收集到的rtrace文件不含指令\n\n执行完run trace之后，会得到一个rtrace文件：\n\n![](看雪2018团队赛-第四题-盗梦空间/img12.png)\n\n所有confuseFunc函数内部执行过的指令约有105010条指令。所以利用idc脚本nop循环是很有必要的。\n\n> run trace之前应该先分析基本块，提前发现妨碍run trace的操作，利用idc脚本nop\n\n# 清洗混淆的rtrace文件\n\n先放上风间仁大佬脚本主体：\n\n![](看雪2018团队赛-第四题-盗梦空间/img13.png)\n\n收集到的原始rtrace.txt约有105010条指令。我们的目标是尽可能的去混淆，使得原始算法指令逻辑清晰可理解。\n\n接下来按照正向思路一步一步分析脚本操作：\n\n> 化简是一步一步的\n\n## pass_nops\n\n首先，在rtrace.txt开头就可以发现指令中有不少影响标志寄存器的指令：\n\n![](看雪2018团队赛-第四题-盗梦空间/img14.png)\n\n全局搜索一下发现rtrace.txt中所有的跳转指令全部是jmp指令，与标志寄存器无关。所以可以确定这些cld,test之类的指令是混淆添加的。\n\n所以第一步，先把这些无用指令（包含我们idc替换的nop指令）先清洗掉。pass_nops函数如下：\n\n![](看雪2018团队赛-第四题-盗梦空间/img15.png)\n\n主要逻辑就是跳过一些无用指令,主要包含：\n- test,cld,cmp,nop,cmc,bt,clc,stc\n- or exx,0x0 # 还是exx\n- and exx, 0xFFFFFFFF # 还是exx\n- call transfor.011F1DEE -> call 0x011F1DEE # 修正call指令。\n\n清洗后，指令数约：84571\n\n## pass_rol_to_ror_all\n\n接着浏览trace_new.txt中的指令，同样开头就可以发现不少rol,ror指令：\n\n![](看雪2018团队赛-第四题-盗梦空间/img16.png)\n\n首先循环移位指令是比较少用的，而且像图中这样连续循环移位更是少见，应该是混淆导致。其次，我们在pass_nops分析中也说了标志寄存器是无用的，所以忽略标志位，rol xx和ror 32-xx是等效的，仔细观察可以发现不少rol和ror指令的立即数超过了32，这些点都是冗余的。为了后续更好的处理，我们把rol和ror指令都统一转化成ror指令，并将rol的立即数做(%32)处理。\npass_rol_to_ror_all函数如下：\n\n![](看雪2018团队赛-第四题-盗梦空间/img17.png)\n\n分别对涉及到的寄存器做rol->ror的指令转换。\n\n由于只做了指令转换，清洗后，指令数没有变化：84571\n\n## pass_edi & pass_ebp\n\n接着浏览新得到的trace_new.txt中的指令，同样开头就可以发现一些优化点：\n\n![](看雪2018团队赛-第四题-盗梦空间/img18.png)\n\n上图3-6行逻辑，基本就是：\n\n```\nmov edi,xxx\nsub/add edi,xxx\n...\nmov exx,[ebp+edixxx]\n```\n\n与之类似的还有：\n\n![](看雪2018团队赛-第四题-盗梦空间/img19.png)\n\n它的pattern是：\n\n```\nmov edi,xxx\nsub/add edi,xxx\n...\nxxx exx,edi\n```\n\n它们的pattern都是类似的，都可以优化成xxx exx,imm或xxx exx,[ebp+imm]。\n\n为了更好的后续分析，这种模式也是需要优化的。其实清洗的过程就是不断优化代码的过程，真正编译器生成的汇编代码不会那么傻，那么多相邻的重复指令。\n\n> 所以看到冗余的点，别想太多，优化就完事了。\n\npass_edi和pass_ebp的主体逻辑就是把以上pattern化为一条指令xxx exx,imm或xxx exx,[ebp+imm]。期间还涉及相邻重复指令的合并，比如连续sub/add。\n\n执行完pass_edi和pass_ebp后，指令数约：68881\n\n## pass_simplify_same_op_all\n\n接着浏览trace_new.txt中的指令，同样开头就可以发现不少相邻的相同指令：\n\n![](看雪2018团队赛-第四题-盗梦空间/img20.png)\n\n这个存在必然也是混淆所影响的，不知道叫啥技术。但是为了汇编代码的可读性，我们仍需要把这种连续的相同指令进行合并。\n\n> 注意，由于我们清洗掉一些指令后，可能原本不相邻的相同指令，变得相邻，所以我们后面会重复调用pass_simplify_same_op_all函数确保清洗彻底。\n\npass_simplify_same_op_all函数：\n\n![](看雪2018团队赛-第四题-盗梦空间/img21.png)\n\n函数功能是对涉及到寄存器的add,sub,ror连续操作进行合并优化。\n\n执行完pass_simplify_same_op_all后，指令数约：52317\n\n## pass_push_pop_eax_ebx_ebx_ecx\n\n接着浏览trace_new.txt中的指令，结合调试会发现confuseFunc中的SMC算法，代码边执行边还原，pattern为：\n\n```\npush eax \npush ebx\npush ecx\n... # SMC\npop ecx\npop ebx\npop eax\n```\n\n这块的指令篇幅巨大，因为每个混淆的代码块的末端都是SMC解码后续的指令，才能继续执行。但在rtrace中，这一段代码与序列号校验算法无关，所以也需要清除掉。\n\npass_push_pop_eax_ebx_ebx_ecx函数内容如下：\n\n![](看雪2018团队赛-第四题-盗梦空间/img22.png)\n\n可以看到函数逻辑就是检测pattern包含的连续指令，跳过它们之间的指令。\n\n执行完pass_push_pop_eax_ebx_ebx_ecx后，指令数骤减为：6013\n\n清洗后我们发现，由于清除掉了一些指令，使得原本不相邻的指令变得相邻，于是trace_new文件中又出现了我们之前清理过的pattern:\n\n![](看雪2018团队赛-第四题-盗梦空间/img23.png)\n\n为了确保清洗彻底，我们将整体的清洗逻辑执行两遍：\n\n![](看雪2018团队赛-第四题-盗梦空间/img24.png)\n\n清洗后，指令数变为：4084\n\n已经大大缩减了指令数\n\n## pass_unused_before_reassign_all\n\n继续浏览新得到的trace_new.txt, 在开头也可以发现一些用于混淆的无用指令：\n\n![](看雪2018团队赛-第四题-盗梦空间/img25.png)\n\n看到连续对一个寄存器操作，最后mov一下，之前的所有操作可以算是无用指令，这样的指令也应该清理掉。\n\npass_unused_before_reassign_all函数如下：\n\n![](看雪2018团队赛-第四题-盗梦空间/img26.png)\n\npass_unused_before_reassign的主要逻辑是：\n1. 如果当前指令中exx作为目标寄存器（即xxx **exx**, imm） -> 向后寻找到下一个含exx的指令\n2. 如果exx作为目标寄存器，说明第一条exx指令是无用的。\n如果exx作为源寄存器，说明第一条指令中exx的值被使用了，指令有效，不清除。\n\n同样为了清洗彻底，反复执行pass_unused_before_reassign_all5次，直到指令数稳定。\n\n清洗后，指令数为：909\n\n指令数又大幅度减少。\n\n## pass_ror_to_shift_all\n\n至此，其实指令已经具备了较好的可读性，可以看到一片局部变量的初始化操作：\n\n![](看雪2018团队赛-第四题-盗梦空间/img27.png)\n\n仔细查看指令，其实已经可以发现一些tea算法的特征，比如ror eax,0x5;ror eax,0x4 相关的指令，循环移位指令并不常用，熟悉tea算法的朋友知道：\n\n![](看雪2018团队赛-第四题-盗梦空间/img28.png)\n\ntea的加解密算法中都有包含shl xxx,4;shr xxx,5 这种类似的指令：\n\n![](看雪2018团队赛-第四题-盗梦空间/img29.png)\n\n仔细观察上图可以发现ror eax,0x5; and eax,0x7FFFFFF 其实等价于shr eax,0x5。说明这两条指令也是被混淆的。\n所以pass_ror_to_shift_all的功能就是把ror exx,imm; and exx,imm;这种组合指令转化为原本的shl/shr指令。\n\n至此，rtrace文件清洗完毕，最终指令数为：843\n\n此时，指令可读性很强，tea算法的特征也表露清晰。\n\n> 仔细一步步化简，守得云开见月明\n\n# 发现tea算法\n\n现在我们可以仔细的审查这800多行指令，识别其算法特征。\n\n![](看雪2018团队赛-第四题-盗梦空间/img30.png)\n\n根据上图可以明显的看出tea的算法特征，比如shl ecx,0x4;shr eax,0x5;xor ecx,edx等仔细观察的话具有明显的tea的痕迹。对照tea的原始加密算法：\n\n![](看雪2018团队赛-第四题-盗梦空间/img28.png)\n\n由此我们可以一步步的翻译指令还原出其变异后的tea算法如下：\n\n```\nvoid encrypt()\n{\n\tDWORD sn[2] = { 0x12345678, 0x90ABCDEF };\n\tconst char *key = \"One shall stand and one shall fall.\";\n\tDWORD *k = (DWORD *)key;\n\tDWORD y = sn[0];\n\tDWORD z = sn[1];\n\tDWORD sum = 0;\n\tDWORD delta = 0x89ABCDEF;\n\tDWORD arg_10 = 0x67452301;\n\tDWORD arg_14 = 0xEFCDAB89;\n\tDWORD arg_18 = 0x98BADCFE;\n\tDWORD arg_1C = 0x10325476;\n\tDWORD arg_20 = 0x7380166F;\n\tDWORD arg_24 = 0x4914B2B9;\n\tDWORD arg_28 = 0x172442D7;\n\tDWORD arg_2C = 0xDA8A0600;\n\n\tsum += delta;\n\ty += ((z << 4) + k[0]) ^ (z + sum) ^ ((z >> 5) + k[1]);\n\tz += ((y << 4) + k[2]) ^ (y + sum) ^ ((y >> 5) + k[3]);\n\ty -= (~arg_10 + 0x3eccd87b) << 7;\n\tz -= (0x548A46D1 - arg_14) >> 9;\n\n\tsum += delta;\n\ty += ((z << 4) + k[0]) ^ (z + sum) ^ ((z >> 5) + k[1]);\n\tz += ((y << 4) + k[2]) ^ (y + sum) ^ ((y >> 5) + k[3]);\n\ty -= (0xFBB23022 - arg_18) << 5;\n\tz -= ((arg_1C - 0x100ca839) >> 6) | arg_28;\n\n\tsum += delta;\n\ty += ((z << 4) + k[0]) ^ (z + sum) ^ ((z >> 5) + k[1]);\n\tz += ((y << 4) + k[2]) ^ (y + sum) ^ ((y >> 5) + k[3]);\n\ty -= (0xF1E85296 - arg_1C) >> 9;\n\tz -= (0x8A6F6B3A - arg_10) << 4;\n\n\tsum += delta;\n\ty += ((z << 4) + k[0]) ^ (z + sum) ^ ((z >> 5) + k[1]);\n\tz += ((y << 4) + k[2]) ^ (y + sum) ^ ((y >> 5) + k[3]);\n\ty -= (~arg_14 - 0x6b9a2d27) << 8;\n\tz -= (arg_1C << 3) + 0xB4915A30;\n\n\tsum += delta;\n\ty += ((z << 4) + k[0]) ^ (z + sum) ^ ((z >> 5) + k[1]);\n\tz += ((y << 4) + k[2]) ^ (y + sum) ^ ((y >> 5) + k[3]);\n\ty -= ((arg_18 - 0x1b9e4315) >> 2) & k[1];\n\tz -= (0xC2CFE269 - arg_10) >> 5;\n\n\tsum += delta;\n\ty += ((z << 4) + k[0]) ^ (z + sum) ^ ((z >> 5) + k[1]);\n\tz += ((y << 4) + k[2]) ^ (y + sum) ^ ((y >> 5) + k[3]);\n\ty -= (0xD8D8F314 - arg_28) << 5;\n\tz -= (0xD4C61A57 - arg_14) >> 6;\n\n\tsum += delta;\n\ty += ((z << 4) + k[0]) ^ (z + sum) ^ ((z >> 5) + k[1]);\n\tz += ((y << 4) + k[2]) ^ (y + sum) ^ ((y >> 5) + k[3]);\n\ty -= ((arg_1C + 0x2077dfe7) >> 8);\n\tz -= (arg_14 + 0x2aedddff) << 4;\n\n\tsum += delta;\n\ty += ((z << 4) + k[0]) ^ (z + sum) ^ ((z >> 5) + k[1]);\n\tz += ((y << 4) + k[2]) ^ (y + sum) ^ ((y >> 5) + k[3]);\n\tprintf(\"%x %x\\n\", y, z);\n}\n```\n\n注意，这里采用的C，当然也可以用python,但首先python会遇到数值溢出32位的情况，需要自行约束，比较麻烦，也比较臃肿。其次本人实验过程中，譬如这句y += ((z << 4) + k[0]) ^ (z + sum) ^ ((z >> 5) + k[1])得到的结果和y = y+ ((z << 4) + k[0]) ^ (z + sum) ^ ((z >> 5) + k[1])结果不一致。遂还是选择了C++.\n\n> 感觉通过汇编指令还原代码，还是C比较方便一些。\n\n# 解密算法\n\n之后根据得到的加密算法书写解密算法，只需把执行顺序颠倒，加减颠倒即可：\n\n```\nz -= ((y << 4) + k[2]) ^ (y + sum) ^ ((y >> 5) + k[3]);\ny -= ((z << 4) + k[0]) ^ (z + sum) ^ ((z >> 5) + k[1]);\nsum -= delta;\n\nz += (arg_14 + 0x2aedddff) << 4;\ny += ((arg_1C + 0x2077dfe7) >> 8);\nz -= ((y << 4) + k[2]) ^ (y + sum) ^ ((y >> 5) + k[3]);\ny -= ((z << 4) + k[0]) ^ (z + sum) ^ ((z >> 5) + k[1]);\nsum -= delta;\n\nz += (0xD4C61A57 - arg_14) >> 6;\ny += (0xD8D8F314 - arg_28) << 5;\nz -= ((y << 4) + k[2]) ^ (y + sum) ^ ((y >> 5) + k[3]);\ny -= ((z << 4) + k[0]) ^ (z + sum) ^ ((z >> 5) + k[1]);\nsum -= delta;\n\nz += (0xC2CFE269 - arg_10) >> 5;\ny += ((arg_18 - 0x1b9e4315) >> 2) & k[1];\nz -= ((y << 4) + k[2]) ^ (y + sum) ^ ((y >> 5) + k[3]);\ny -= ((z << 4) + k[0]) ^ (z + sum) ^ ((z >> 5) + k[1]);\nsum -= delta;\n\nz += (arg_1C << 3) + 0xB4915A30;\ny += (~arg_14 - 0x6b9a2d27) << 8;\nz -= ((y << 4) + k[2]) ^ (y + sum) ^ ((y >> 5) + k[3]);\ny -= ((z << 4) + k[0]) ^ (z + sum) ^ ((z >> 5) + k[1]);\nsum -= delta;\n\nz += (0x8A6F6B3A - arg_10) << 4;\ny += (0xF1E85296 - arg_1C) >> 9;\nz -= ((y << 4) + k[2]) ^ (y + sum) ^ ((y >> 5) + k[3]);\ny -= ((z << 4) + k[0]) ^ (z + sum) ^ ((z >> 5) + k[1]);\nsum -= delta;\n\nz += ((arg_1C - 0x100ca839) >> 6) | arg_28;\ny += (0xFBB23022 - arg_18) << 5;\nz -= ((y << 4) + k[2]) ^ (y + sum) ^ ((y >> 5) + k[3]);\ny -= ((z << 4) + k[0]) ^ (z + sum) ^ ((z >> 5) + k[1]);\nsum -= delta;\n\nz += (0x548A46D1 - arg_14) >> 9;\ny += (~arg_10 + 0x3eccd87b) << 7;\nz -= ((y << 4) + k[2]) ^ (y + sum) ^ ((y >> 5) + k[3]);\ny -= ((z << 4) + k[0]) ^ (z + sum) ^ ((z >> 5) + k[1]);\nsum -= delta;\n```\n\n最终得到序列号:285764B86F41B019\n\n# 总结\n\n这题考察分析者的识别反调试，去混淆脚本，识别常用加密算法等能力。\n通过此题，学习到了z3工具的使用，去混淆脚本的编写思路，受益良多，再次感谢风间仁大佬。\n\n# 参考链接\n\n[题目发布页](https://ctf.pediy.com/game-team_fight-76.htm)\n\n[风间仁大佬wp](https://bbs.pediy.com/thread-248277.htm)\n\n[Riatre大佬wp](https://bbs.pediy.com/thread-248285.htm)\n","tags":["windows","混淆","Crypto","反调试"],"categories":["逆向"]},{"title":"IDA pro使用技巧","url":"/2018/12/15/IDA-pro使用技巧/"}]